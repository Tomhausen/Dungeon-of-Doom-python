{
  "README.md": " \n\n\n> Open this page at [https://ashalls.github.io/tcz-modders-tilemaps-advanced/](https://ashalls.github.io/tcz-modders-tilemaps-advanced/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [/](/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/ashalls/tcz-modders-tilemaps-advanced** and import\n\n## Edit this project ![Build status badge](https://github.com/ashalls/tcz-modders-tilemaps-advanced/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [/](/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/ashalls/tcz-modders-tilemaps-advanced** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/ashalls/tcz-modders-tilemaps-advanced/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/arcade\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n",
  "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"~qzW~AEeCLPI]lX]1%J[\">mySprite</variable></variables><block type=\"pxt-on-start\" id=\"@tiGom@XMTPypSSXb]k-\" x=\"0\" y=\"0\"></block></xml>",
  "main.ts": "\n",
  "pxt.json": "{\n    \"name\": \"Tiles Advanced\",\n    \"version\": \"1.2.3\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"controller\": \"*\",\n        \"arcade-tilemap-a-star\": \"github:jwunderl/arcade-tilemap-a-star#v0.4.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"tilesadvanced.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"1.12.30\",\n        \"pxt\": \"8.5.2\",\n        \"targetId\": \"arcade\"\n    },\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n",
  "test.ts": "",
  "tilesadvanced.ts": "//% weight=0 color=#13a89e icon=\"\\uf041\" block=\"Tiles Advanced\"\n//% advanced=false\n//% groups=\"['Local Tiles', 'Tilemap Population', 'Tile Comparisons', 'Tile Animation', 'Pathfinding']\"\n\nnamespace tilesAdvanced {\n    /**\n     * Returns a list of tiles in a plus sign within a tile in a given range\n     */\n    //% blockId=getAdjacentTiles\n    //% block=\"get tiles near to $tile within $distance\"\n    //% group=\"Local Tiles\"\n    //% weight=20\n    export function getAdjacentTiles(tile: tiles.Location, distance: number): tiles.Location[] {\n        let i: number;\n        let col = tile.col;\n        let row = tile.row;\n        let adjacent_tiles = [tile];\n\n        for (i = 0; i < distance; i++) {\n            adjacent_tiles.push(tiles.getTileLocation(col - i, row))\n        }\n        for (i = 0; i < distance; i++) {\n            adjacent_tiles.push(tiles.getTileLocation(col + i, row))\n        }\n        for (i = 0; i < distance; i++) {\n            adjacent_tiles.push(tiles.getTileLocation(col, row - i))\n        }\n        for (i = 0; i < distance; i++) {\n            adjacent_tiles.push(tiles.getTileLocation(col, row + i))\n        }\n        return adjacent_tiles\n    }\n\n    /**\n     * Returns true if the given tiles are the same tile\n     */\n    //% blockId=tileIsTile\n    //% block=\"$tile is $otherTile\"\n    //% group=\"Tile Comparisons\"\n    //% weight=20\n    export function tileIsTile(tile: tiles.Location, otherTile: tiles.Location): boolean {\n        if (tile.col == otherTile.col && tile.row == otherTile.row) {\n            return true\n        }\n        return false\n    }\n\n    /**\n     * Returns true if the given tile is in the list of tiles provided\n     */\n    //% blockId=tileIsInList\n    //% block=\"$tile is in $tileList\"\n    //% group=\"Tile Comparisons\"\n    //% weight=20\n    export function tileIsInList(tile: tiles.Location, tileList: tiles.Location[]): boolean {\n        for (let tileInList of tileList) {\n            if (tileIsTile(tile, tileInList)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    /**\n     * Sets the wall on or off for all tiles of a given type\n     */\n    //% blockId=setWallOnTilesOfType\n    //% block=\"set walls $makeWall on tiles of type $tile\"\n    //% group=\"Tilemap Population\"\n    //% weight=20\n    export function setWallOnTilesOfType(tile: Image, makeWall: boolean) {\n        for (let tileOfType of tiles.getTilesByType(tile)) {\n            tiles.setWallAt(tileOfType, makeWall)\n        }\n    }\n\n    /**\n     * Animates all tiles of the given type with the animation passed in on the interval given\n     */\n    //% blockId=animateTileOfTypeWith\n    //% block=\"animate $tile with $animation every $frameLength\"\n    //% group=\"Tile Animation\"\n    //% weight=20\n    export function animateTileOfTypeWith(tile: Image, animation: Image[], frameLenght: number) {\n        let frame = 0\n        let tilesToAnimate = tiles.getTilesByType(tile)\n        game.onUpdateInterval(frameLenght, function animateTiles() {\n            for (let tileOfType of tilesToAnimate) {\n                tiles.setTileAt(tileOfType, animation[frame])\n            }\n            frame += 1\n            if (frame == animation.length - 1) {\n                frame = 0\n            }\n            console.log(frame)\n        })\n    }\n\n    /**\n     * Makes this sprite follow the target sprite using pathfinding\n     */\n    //% blockId=followUsingPathfinding\n    //% block=\"set %sprite(myEnemy) follow %target=variables_get(mySprite) || with speed %speed\"\n    //% group=\"Pathfinding\"\n    //% weight=20\n    export function followUsingPathfinding(sprite: Sprite, target: Sprite, speed = 100){\n        let myStart = sprite.tilemapLocation();\n        let path = scene.aStar(myStart, target.tilemapLocation())\n        scene.followPath(sprite, path, speed)\n        game.onUpdate(function tick(){\n            if (!tileIsTile(sprite.tilemapLocation(), myStart)){\n                myStart = sprite.tilemapLocation();\n                path = scene.aStar(myStart, target.tilemapLocation())\n                scene.followPath(sprite, path, speed)\n            }\n        })\n    }\n}\n\n"
}